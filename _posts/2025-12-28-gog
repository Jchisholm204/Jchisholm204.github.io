---
title: Geometric Obstacle Generation
date: 2025-10-19
categories:
  - Robotics
tags:
  - C
author: Jacob
math: true
---
*Abstract* - Testing path planners in high dimensional environments poses a significant challenge known as *the curse of dimensionality*.
As the number of dimensions in the problem grow linearly, the size of the configuration space and obstacle space grow exponentially.
To address this challenge, I present the Geometric Obstacle Generator (GOG), a simplistic, procedural, and deterministic obstacle generation method.

## Introduction
Evaluating motion planning algorithms in high-dimensional configuration spaces requires environments that are both computationally challenging and efficient to evaluate. 
Traditionally, obstacles are represented as explicit hypercubes or hyperspheres, used to mark invalid regions within the space.
However, these representations become increasingly impractical as dimensionality grows due to rising memory requirements and expensive geometric collision checks.

The Geometric Obstacle Generator (GOG) was developed to address these limitations by replacing explicit obstacle storage with an implicit, procedural formulation. 
Rather than storing obstacle geometry, GOG determines configuration validity analytically using a small number of arithmetic and bitwise operations. 
This approach allows obstacle density to remain high while keeping collision checks fast and memory usage constant.

Because the obstacle field is generated deterministically and evaluated on demand, GOG scales naturally to higher-dimensional spaces without modification. 
These properties make it particularly well suited for benchmarking and stress-testing motion planners in dense and narrow-passage environments, where collision checking performance is often the dominant computational cost.

## Core Idea
Rather than explicitly storing and enumerating all obstacles within the environment, each configuration point is is classified as valid or invalid using a deterministic hash function.

> **Info**
> The following code assumes that each axis lies within the bounds [0, 100), and uses `uint8_t` representation to avoid excess memory usage.
> To use a higher valued space, the `unsigned char` representation can be changed to a higher bit-width representation.
{: .prompt-info}

For each axis, two bits are produced, leading to the four possible outcomes  $x_i \in \set{0, 1, 2, 3}$.
If the summation of the bits generated by all axes exceeds a preset threshold, then the point is classified as invalid.

```c
/**
 * @brief Check if a point is valid/invalid
 *
 * @param gog The GOG object pointer
 * @param p point to check
 * @returns 1 if invalid, 0 otherwise (including failure)
 */
static inline bool gog_check(gog_t *gog, const state_t *p) {
	// Prevent NULL Access
    if (!gog || !p) {
        return false;
    }
	// BEGIN Benchmarking
    gog->access_counter++;
	// END Benchmarking
    unsigned char invalid = 0x00;
    for (size_t i = 0; i < STATESPACE_DIMS; i++) {
	    unsigned char dim_val = point ^ gog->variable[axis];
	    unsigned char pattern = (point >> gog->patterns[axis]);
		unsigned char dim_inval = (pattern + dim_val);
	    dim_inval = (dim_inval >> gog->bmasks[axis]);
	    invalid += ((dim_inval) & 0x03);
    }
    return invalid >= GOG_THRESH;
}
```

### Proof of Construction
Assume that there is a $d$ dimensional state $x_d$,  and that the hash function used is equivalent to the following statement:
$$
\begin{equation}
\label{eq:hash}
h_i = x_i[0:1] , \forall 0 \le i \lt d
\end{equation}
$$
That is, that for all $x_i$ values in the state $x$, the hash function for $x_i$ is equivalent to its two lowest bits.

Then, because we are in a binary world, each one of the resultant values {0, 1, 2, 3} will occur at repeatable and predictable intervals.


### Proof of 
Given an infinitely value discrete world, the probability of any value $j \in \set{0, 1, 2, 3}$ is equal to equation \eqref{eq:prob}.
$$
\begin{equation}
\label{eq:prob}
p_j = \frac{1}{4} \forall j \in \set{0, 1, 2, 3}
\end{equation}
$$

Additionally, given 